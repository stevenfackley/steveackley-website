name: CI / Deploy to GHCR & EC2

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    name: Build & Push to GHCR
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
      image_ref: ghcr.io/stevenfackley/steveackley-web@${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/stevenfackley/steveackley-web:latest
            ghcr.io/stevenfackley/steveackley-web:sha-${{ github.sha }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
          # Dummy DATABASE_URL for build-time Prisma generate — never used in production.
          # Real DATABASE_URL is injected at container runtime via web.env.
          build-args: |
            DATABASE_URL=postgresql://build:build@localhost:5432/builddb

  deploy:
    name: Deploy to EC2
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          port: 22
          # Pass secrets as env vars into the SSH session
          envs: DATABASE_URL,AUTH_SECRET,ADMIN_PASSWORD_HASH,POSTGRES_PASSWORD,GHCR_TOKEN,GHCR_USER,IMAGE_REF
          script: |
            set -e
            cd ${{ secrets.EC2_APP_DIR }}

            if [ -z "$IMAGE_REF" ]; then
              echo "ERROR: IMAGE_REF is empty"
              exit 1
            fi

            echo "==> Deploying image ref: $IMAGE_REF"

            echo "==> Log in to GHCR"
            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin

            echo "==> Pull latest code (compose file, configs)"
            git pull origin main

            echo "==> Removing old .env (prevents Docker Compose $ interpolation)"
            rm -f .env

            echo "==> Writing web.env file for web container"
            # Escape $ as $$ in bcrypt hash so Docker Compose doesn't interpolate
            ESCAPED_HASH=$(printf '%s' "$ADMIN_PASSWORD_HASH" | sed 's/\$/\$\$/g')
            printf 'DATABASE_URL=%s\nAUTH_SECRET=%s\nADMIN_PASSWORD_HASH=%s\n' \
              "$DATABASE_URL" "$AUTH_SECRET" "$ESCAPED_HASH" > web.env
            chmod 600 web.env

            echo "==> Writing postgres secret file"
            mkdir -p secrets
            printf '%s' "$POSTGRES_PASSWORD"      > secrets/postgres_password.txt
            chmod 600 secrets/postgres_password.txt

            echo "==> Verifying web.env file"
            echo "  web.env: $(wc -l < web.env) lines, $(wc -c < web.env) bytes"
            # Show keys only (not values)
            awk -F= '{print "  ✓ " $1}' web.env
            echo "  secrets/postgres_password.txt: $(wc -c < secrets/postgres_password.txt) bytes"

            echo "==> Ensuring web network exists"
            docker network create web 2>/dev/null || true

            echo "==> Pulling image and restarting"
            IMAGE_REF="$IMAGE_REF" docker compose pull web
            IMAGE_REF="$IMAGE_REF" docker compose up -d --remove-orphans

            echo "==> Waiting for container to start..."
            sleep 15

            echo "==> Container logs (full startup):"
            docker logs steveackley-web 2>&1 || true

            echo "==> Container status:"
            docker ps --filter name=steveackley-web --format "{{.Status}}" || true

            echo "==> DB container status:"
            docker ps --filter name=steveackley-db --format "{{.Status}}" || true

            echo "==> Health check — hitting http://localhost:3000/"
            curl -sS -o /tmp/health_response.txt -w "HTTP_STATUS: %{http_code}\n" http://localhost:3000/ 2>&1 || true
            echo "==> Response body (first 500 chars):"
            head -c 500 /tmp/health_response.txt 2>/dev/null || true
            echo ""

            echo "==> Health check — hitting http://localhost:3000/admin/login"
            curl -sS -o /dev/null -w "HTTP_STATUS: %{http_code}\n" http://localhost:3000/admin/login 2>&1 || true

            echo "==> Container logs AFTER health check:"
            docker logs steveackley-web --tail 40 2>&1 || true

            echo "==> Pruning old images"
            docker image prune -f

            echo "==> Deploy complete ✓"
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          ADMIN_PASSWORD_HASH: ${{ secrets.ADMIN_PASSWORD_HASH }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GHCR_USER: ${{ github.actor }}
          IMAGE_REF: ${{ needs.build-and-push.outputs.image_ref }}

      - name: Purge Cloudflare Cache
        run: |
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}' \
            --fail-with-body
          echo "✓ Cloudflare cache purged"
